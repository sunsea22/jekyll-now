---
layout: post
title: shell学习
---

shell脚本编程


   接触shell编程不久，对一些关于shell编程的面试题做一些整理

### 从a.log文件中提取包含”WARNING“或“FATAL”，同时不包含“IGNOR”的行，然后，提取以“：”分割的第五个字段？
```javascript
   grep -E 'WARNING|FATAL' a.log | grep -v 'IGNOR' | awk -F : '{print $5 }'	
```

### 添加一个新组为class01，然后，添加属于这个组的30个用户，用户名的形式为stdXX，其中，XX从01到30？
```javascript
#!/bin/bash
   groupadd class01
   for((i=1;i<=9;i++))
   do
        useradd std0$i -G class01
   done

   for((i=10;i<=30;i++))
   do
        useradd std$i -G class01
   done

```

### 编写shell程序，实现自动删除50个账号的功能。账号名为stud1至stud50
```javascript
#!/bin/bash
i=1

while[ $i le 50 ]
do
	userdel -r stud${i}
	i=$(($i+1))
done
```

### 在每个月的第一天备份并压缩/etc目录下的所有内容，存放在/root/backup目录里，且文件名为如下形式yymmdd_etc，yy为年，dd为日。shell程序fileback存放在/usr/bin目录下？
```javascript
tar -zcf /root/backup/'date+%y%m%d'_etc /etc
```

### 用shell编程，判断一个文件是不是字符设备文件，如果是将其拷贝到/dev目录下？
```javascript
#!/bin/bash
if test$# -ne 1
then
     echo "ERROR"
     exit 1
fi
if test -c $1
then 
      /bin/cp -a $1 /dev/
      exit 0
fi
  exit 1
```

#### Linux中shell变量说明：
```javascript
$$ shell本身的PID
$! shell最后运行的后台Process的PID
$? 最后运行的命令的结束代码（返回值）
$- 使用Set命令设定的Flag一览
$*/$@ 所有参数列表
$# 添加到shell的参数个数
$0 shell本身的文件名
$1~$n
添加到shell的各参数值。$1是第1个参数，$2是第2个参数
```


#### `cp -a`的用法
对于`cp -a`最主要的用法是在保留原文件属性的前提下复制文件。

其实还有个很好的用法，如下：
大家都知道linux下复制目录可以通过`cp -r dirname destdir`
但是这样复制的目录属性会发生变化，想要使得复制之后的目录和源目录完全一样，可以使用`cp -a dirname destdir`

#### test命令用法
```javascript
test -n 字符串 字符串的长度非零
test -z 字符串 字符串的长度为零
test File1 -ef File2 两个文件具有同样的设备号和i结点号
test File1 -nt File2 文件1比文件2新
test File1 -ot File2 文件1比文件2旧
test -b File 文件存在并且是块设备文件
test -c File 文件存在并且是字符设备文件
test -d File 文件存在并且是目录
```

### 某系统管理员需要每天做一定的重复工作，编制一个解决方案：
(1)从下午4：50删除/abc目录下的全部子目录和全部文件;
(2)从早上8：00~下午6：00每小时读取/xyz目录下x1文件中每行第一个域的全部数据加入到/backup目录下的back01.txt文件内；
(3)每逢周一下午5：50将/data目录下的所有目录和文件归档并压缩为文件backup.tar.gz;
(4)在下午5：55将IDE接口的CD-ROM卸载（假设CD-ROM的设备名为hdc）；
(5)在早上8：00开机后启动

#### 使用计划任务来完成：
```javascript
crontab -e
-----------------------
50 16 * * * rm -rf /abc/*
00 08-18 * * * awk '{print$1 }' /xyz/x1 >> /backup/back01.txt
50 17 * * 01 tar -zcf /backup/backup.tar.gz /data
55 17 * * * umout /dev/hdc
-----------------------
设定BIOS每日上午08：00开机
```

### 编写个shell脚本将当前目录下大于10K的文件转移到/tmp目录下

```javascript
#!/bin/bash
for FileName in 'ls -l | awk '$5 > 10240 {print $9}''
do mv $FileName /tmp
done
ls -al /tmp
echo "Done!"
```

### 编写shell脚本获取本机的网络地址

#### 比如：本机的ip地址是：192.168.100.2/255.255.255.0，那么它的网络地址是192.168.100.2/255.255.255.0
```javascript
方法一：
#!/bin/bash

file="/etc/sysconfig/network-scripts/ifcfg-eth0"

if [ -f $file ]
then
	IP='grep "IPADDR" $file | awk -f "=" '{print $2}''
	MASK='grep "NETMASK" $file | awk -f "=" '{print $2}''

	echo "$IP/$MASK
exit 1"
fi
```

#### Linux常用逻辑判断
```javascript
-b file 若文件存在且是一个块特殊文件，则为真
-c file 若文件存在且是一个字符特殊文件，则为真
-d file 若文件存在且是一个目录，则为真
-e file 若文件存在，则为真
-f file 若文件存在且是一个规则文件，则为真
-z string 若string长度为0，则为真
-n string 若string长度不为0，则为真
```

```javascript
方法二：
#!/bin/bash

IP='ifconfig eth0 | grep 'inet ' | sed 's/^.*addr://g' | sed 's/Bcast.*$//g''
NETMASK='ifconfig eth0 | grep 'inet ' | sed 's/^.*Mask://g''

echo "$IP/$NETMASK

exit"
```

### 设计一个shell程序，在每月第一天备份并压缩/etc目录的所有内容，存放在/root/bak目录里，且文件名为如下形式yymmdd_etc，yy为年，mm为月，dd为日。shell程序fileback存放在/usr/bin目录下。
```javascript
#!/bin/bash
DIRNAME='ls /root | grep bak'
if [ -z $"DIENAME" ]
then
	mkdir /root/bak
	cd /root/bak
fi

YY='date +%y'
MM='date +%m'
DD='date +%d'
BACKETC=$YY$MM$DD_etc.tar.gz
tar zcvf $BACKETC /etc
echo "fileback finished"
```

### 有一个普通用户想在每周日凌晨零点零分定期备份/user/backup到/tmp目录下，该用户如何做？

#### 方法一
```javascript
用户应使用crontab -e命令创建crontab文件。格式如下：
0 0 * * sun cp -r /user/backup /tmp
```

#### 方法二
```javascript
用户先在自己的目录下新建文件file，文件内容如下：
0 0 * * sum cp -r /user/backup /tmp
然后执行crontab file使生效
```

### 设计一个shell程序，在/userdata目录下建立50个目录，即user1~user50，并设置每个目录的权限，其中其他用户的权限为：读；文件所有者的权限为：读、写、执行；文件所有者所在组的权限为：读、执行。
```javascript
#!/bin/bash
i=1
while [ $i le 50]
do
	if [ -d /userdata ];then
		mkdir -p /userdata/user$i
		chmod 754 /userdata/user$i
		echo "user$i"
		i=$(($i+1))
	else
		mkdir /userdata
		mkdir /userdata/user$i
		chmod 754 /userdata/user$i
		echo "user$i"
		i=$(($i+1))
	fi
done
```
----
****
